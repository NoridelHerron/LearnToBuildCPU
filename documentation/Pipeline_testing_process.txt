I started testing both Pipeline using the following step
Step 1: Initialize the Pipeline with basic instruction, so I know what value to expect.
									EXPECTED
	rom[0] = 32'h001a8193;     		// addi x3, x21 1  		1
        rom[1] = 32'h00250213;     		// addi x4, x10 2		2
        rom[2] = 32'h00330313;     		// addi x6, x6 3 	  	3
        rom[3] = 32'h00a183b3;     		// addi x7, x3, x10		1
        rom[4] = 32'h004a8433;     		// addi x8, x21, x4		2
        for (i = 5; i < 1024; i = i + 1) begin	// NOP 
            rom[i] = 32'h00000013;
        end

Problem I encountered while observing the Pipeline, after the 3rd instruction, I did not see the expected value (1 (4th instr), 2 (4th instr)). I suspected the register file causing it because I initially did not handle the if rd and rs and isWrite case.
To confirm this, I inserted NOP instruction before that, and confirmed, the register value is coming too late.
Solution: I just added an assertion in the register file that if that's the case, just return the wb data to the register source that's needing that data.


Step 2: Check if hazard (forwarding) resolution works.  
							NO_Forw 	Forw
	rom[0] = 32'h00150393;  // addi x7, x10 1	1		1	
        rom[1] = 32'h00248413;  // addi x8, x9  2	2		2
        rom[2] = 32'h008385b3;  // add x11, x7 x8	0		3
        rom[3] = 32'h00b406b3;  // add x13, x8 x11	0		5
        rom[4] = 32'h00b687b3;  // add x15, x13 x11	0		8
        rom[5] = 32'h00338993;  // addi x19, x7 3	4		4
        rom[6] = 32'h00338a13;  // addi x20, x7 3	4		4
        
        for (i = 7; i < 1024; i = i + 1) begin
            rom[i] = 32'h00000013;
        end
	
	Confirmed: result is as expected

	rom[0] = 32'h00150393;
        rom[1] = 32'h0023a023;
        rom[2] = 32'h00338313;
        rom[3] = 32'h00012503;
        rom[4] = 32'h00130493;
        rom[5] = 32'h00130493;
        rom[6] = 32'h009505b3;
        
        for (i = 7; i < 1024; i = i + 1) begin
            rom[i] = 32'h00000013;
        end
