I started testing both Pipeline using the following step
Step 1: Initialize the Pipeline with basic instruction, so I know what value to expect.
									EXPECTED
	rom[0] = 32'h001a8193;     		// addi x3, x21 1  		1
        rom[1] = 32'h00250213;     		// addi x4, x10 2		2
        rom[2] = 32'h00330313;     		// addi x6, x6 3 	  	3
        rom[3] = 32'h00a183b3;     		// addi x7, x3, x10		1
        rom[4] = 32'h004a8433;     		// addi x8, x21, x4		2
        for (i = 5; i < 1024; i = i + 1) begin	// NOP 
            rom[i] = 32'h00000013;
        end

Problem I encountered while observing the Pipeline, after the 3rd instruction, I did not see the expected value (1 (4th instr), 2 (4th instr)). I suspected the register file causing it because I initially did not handle the if rd and rs and isWrite case.
To confirm this, I inserted NOP instruction before that, and confirmed, the register value is coming too late.
Solution: I just added an assertion in the register file that if that's the case, just return the wb data to the register source that's needing that data.


Step 2: Check if hazard (forwarding) resolution works.  
							NO_Forw 	Forw
	rom[0] = 32'h00150393;  // addi x7, x10 1	1		1	
        rom[1] = 32'h00248413;  // addi x8, x9  2	2		2
        rom[2] = 32'h008385b3;  // add x11, x7 x8	0		3
        rom[3] = 32'h00b406b3;  // add x13, x8 x11	0		5
        rom[4] = 32'h00b687b3;  // add x15, x13 x11	0		8
        rom[5] = 32'h00338993;  // addi x19, x7 3	4		4
        rom[6] = 32'h00338a13;  // addi x20, x7 3	4		4
        
        for (i = 7; i < 1024; i = i + 1) begin
            rom[i] = 32'h00000013;
        end
	
	Confirmed: result is as expected

Step 3:

	rom[0] = 32'h00150393; 	// addi x7, x10 1 
        rom[1] = 32'h0023a023;	// sw x7, 0(x2)
        rom[2] = 32'h00338313;	// addi x6, x7 3
        rom[3] = 32'h00012503;  // lw x10, 0(x2)
        rom[4] = 32'h00130493;	// addi x9, x6 1         
	rom[5] = 32'h009505b3;	// addi x11, x10 x9  
        
        for (i = 6; i < 1024; i = i + 1) begin
            rom[i] = 32'h00000013;
        end

Step 4:
	
	rom[0] = 32'h00150393; 	// addi x7, x10 1 
        rom[1] = 32'h0023a023;	// sw x7, 0(x2)
        rom[2] = 32'h00338313;	// addi x6, x7 3
        rom[3] = 32'h00012503;  // lw x10, 0(x2)        
	rom[4] = 32'h009505b3;	// add x11, x10 x9  

	for (i = 4; i < 1024; i = i + 1) begin
            rom[i] = 32'h00000013;

Step 4:
	
	rom[0] = 32'h00010663; 	// beq x2, x0 12 
        rom[1] = 32'h001a81b3;	// addi x3, x21 1
        rom[2] = 32'h00250233;	// addi x4, x10 2
        rom[3] = 32'h00338313;  // addi x6, x7 3       
	rom[4] = 32'h00150393;	// addi x7, x10 1 
	rom[5] = 32'h0063da63;  // bege x7, x6 20	        
	rom[6] = 32'h00248413;  // addi x8, x9 2	
 	rom[7] = 32'h008385b3;  // add x11, x7 x8

	for (i = 8; i < 1024; i = i + 1) begin
            rom[i] = 32'h00000013;

   